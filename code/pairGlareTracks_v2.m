function [dualTracks,filterTracks] = pairGlareTracks_v2(tracks,maxDist,maxRelVelDiff,minLenSim,maxRelVar)
% pair up tracks of glare points by checking if they are close in space,
% velocity and simultaneous in time
% inputs:
%   tracks: 2d or 3d tracks generated by trackparticles % NOTE: tracks should include velocities
%   maxDist: maximum distance between two tracks to be paired
%   maxRelVelDiff: max relative velocity difference ~[0,1]
%   minLenSim: minimum number of frames they should overlap
%   maxRelVar: maximum relative variance in distance between point ~[0,1]
% outputs:
%   dualTracks: c by 2 struct of paired up tracks where c is the number of
%               successful pairs
%   filterTracks: array of struct including paired and unpaired tracks


if ~exist('maxRelVar','var')
    maxRelVar = 0.2;
end
if ~exist('minLenSim','var')
    minLenSim = 5;
end
if ~exist('maxNormStd','var')
    maxNormStd = 0.1;
end

% initialize
ntracks = numel(tracks);
dualTracks = [];
filterTracks = [];

% set up availability of tracks
for ii = 1:ntracks
    tracks(ii).avail = ones(tracks(ii).len,1); % to start everything is available
end


% loop over all the tracks
h = waitbar(0,'Pairing Tracks ...');
for ii = 1:ntracks
    
    % set up tracks to search over
    tracksB = tracks;
    tracksB(ii).time = -1; % omit the current track from search

    % compute costs over other tracks
    for jj = 1:numel(tracksB)
        
        % what times are both tracks active
        [bothTime,idx_a,idx_b] = intersect(tracks(ii).time,tracksB(jj).time);

        % of these times when are both tracks available
        bothAvail = tracks(ii).avail(idx_a) & tracks(jj).avail(idx_b);
       
        if sum(bothAvail) > minLenSim 
            
            % ----------- find indices when each is available -------
            idx_a = idx_a(bothAvail);
            idx_b = idx_b(bothAvail);

            % ----------- compute costs --------------------
            dists = sqrt( sum((tracks(ii).pos(idx_a,:) - tracksB(jj).pos(idx_b,:)).^2,2) );
            distStd = std(dists);
            distMax = max(dists); % distance variance and maximum
        
            velDiff = sum((tracks(ii).U(idx_a,:) - tracksB(jj).U(idx_b,:)).^2,2);
            [maxVelDiff,indx] = max(velDiff); % maximum raw velocity difference

            velRelDiff = maxVelDiff/norm(tracks(ii).U(idx_a(indx),:)); % max difference in relative velocity (at time of max difference raw)

            if distMax < maxDist && distStd/maxDist < maxNormStd && velRelDiff < maxRelVelDiff % try to pair them
               % clear the availability
               tracks(ii).avail(idx_a) = 0;
               tracks(jj).avail(idx_b) = 0;
               
               % --- for settling velocity experiments ---------- 
               % assign the tracks to each side
               newTrackA.pos = tracks(ii).pos(idx_a,:);
               newTrackA.U = tracks(ii).U(idx_a,:);
               newTrackA.time = bothTime(bothAvail);
               newTrackA.len = length(idx_a);

               newTrackB.pos = tracksB(jj).pos(idx_b,:);
               newTrackB.U = tracksB(jj).U(idx_b,:);
               newTrackB.time = bothTime(bothAvail);
               newTrackB.len = length(idx_b);

               dualTracks = [dualTracks;
                             newTrackA newTrackB];

               % ----- for merging into one track ------
               filterTrack.time = bothTime(bothAvail);
               filterTrack.len = length(filterTrack.time);
               filterTrack.pos = (dualTracks(end,1).pos + dualTracks(end,2).pos)/2; % avg position
               filterTrack.U = (dualTracks(end,1).U + dualTracks(end,2).U)/2; % avg position
               filterTracks = [filterTracks; 
                                filterTrack];
            end
        end
    end
    
    waitbar(ii/ntracks,h);
end
close(h);
nPair = size(dualTracks,1);
disp(['Number of Tracks Paired: ' num2str(nPair) ])
% now append the unpaired tracks to filter tracks
for ii = 1:numel(tracks)
    stillAvail = find(tracks(ii).avail == 1); % when hasnt this track been paired
    if ~isempty(stillAvail) % if it hasnt been paired in at least one frame
        % make a track
        filterTrack.time = tracks(ii).time(stillAvail);
        filterTrack.pos = tracks(ii).pos(stillAvail,:);
        filterTrack.U = tracks(ii).U(stillAvail,:);
        filterTrack.len = length(stillAvail);
        filterTracks = [filterTracks;
                        filterTrack];

    end
end

